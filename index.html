<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Flashcard Nh·∫≠t ‚Äì Created by ƒêen Khui</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #ffe0f5, #ffd6f0);
            margin: 0;
            padding: 0;
        }

        h1 {
            text-align: center;
            color: #ff97df;
            font-size: 46px;
            margin-top: 18px;
            text-shadow:
                0 0 8px white,
                0 0 15px #ffb7ef,
                0 0 30px #ff7bda;
            font-weight: 700;
        }

        .container {
            width: 92%;
            max-width: 1000px;
            margin: 18px auto 40px;
        }

        .box {
            background: rgba(255, 245, 252, 0.95);
            padding: 16px;
            border-radius: 12px;
            box-shadow: 0 0 15px rgba(255, 150, 230, 0.35);
            margin-bottom: 16px;
        }

        label {
            font-size: 18px;
            font-weight: 600;
            display: block;
            margin-bottom: 6px;
        }

        input[type=text], textarea {
            width: 100%;
            padding: 10px;
            margin: 8px 0 12px;
            border-radius: 10px;
            border: 2px solid #ffa6e9;
            box-sizing: border-box;
            font-size: 16px;
        }

        textarea { resize: vertical; min-height:60px; }

        button {
            padding: 10px 16px;
            border: none;
            background: #ff7ed8;
            color: white;
            font-size: 15px;
            font-weight: 600;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 8px #ffb3ef;
            margin-right: 8px;
            margin-top: 6px;
        }

        button:hover { background: #ff58c5; }

        .card {
            width: 100%;
            height: 260px;
            margin-top: 12px;
            perspective: 1200px;
        }

        .inner {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: 0.5s;
        }

        .flipped { transform: rotateY(180deg); }

        .side {
            width: 100%;
            height: 100%;
            position: absolute;
            backface-visibility: hidden;
            display:flex;
            justify-content: center;
            align-items: center;
            font-size: 63px;
            font-weight: 700;
            color: #4b0036;
            background: rgba(255,239,250,0.85);
            border: 2px solid #ffa6e9;
            border-radius: 18px;
            padding: 12px;
            box-sizing: border-box;
            text-align: center;
        }

        .back { transform: rotateY(180deg); }

        .center { text-align: center; margin-top: 14px; }

        .signature { text-align:center; margin-top: 18px; font-size: 15px; color:#ff7ed8; font-weight:700; }

        .two-cols { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        @media (max-width: 800px) { .two-cols { grid-template-columns: 1fr; } }

        .muted { font-size: 13px; color: #6b0060; margin-top:6px; }
        .small { font-size: 13px; padding:6px 10px; border-radius:8px; }
    </style>
</head>
<body>

    <h1>M√†y h·ªçc ti·∫øng Nh·∫≠t gi√πm tao c√°iiiiii</h1>

        <!-- BULK / IMPORT -->
        <div class="box">
            <h3 style="margin:0 0 8px 0;">Import</h3>
            <div class="two-cols">
                <div>
                    <label>c∆∞ng h√£y d√°n t·ª´ v·ª±ng c∆∞ng c·∫ßn h·ªçc v√¥ ƒë√¢y nha c∆∞nggg </label>
                    <textarea id="pasteFromWord" placeholder="C∆∞ng copy m·∫•y t·ª´ c∆∞ng h·ªçc √° pas v√†o ƒë√¢y. Example: &#10;Áä¨ - con ch√≥&#10;Áå´ - con m√®o"></textarea>
                    <button onclick="bulkAddFromPaste()">‚ö° T·∫°o th·∫ª t·ª´ d√°nüç£üçôüç•üç±üçùüçïüçî</button>
                    <div class="muted">Sau khi nh·∫≠p xong t·∫•t c·∫£ t·ª´ v·ª±ng th√¨ b·∫•m n√∫t n√†y</div>
                </div>
                        <button onclick="clearCurrentLesson()">üßπ X√≥a to√†n b·ªô b√†i n√†y</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- NAVIGATION -->
        <div class="box center">
            <button onclick="prevCard()">‚¨Ö Th·∫ª tr∆∞·ªõc</button>
            <button onclick="nextCard()">‚û° Th·∫ª sau</button>

            <button onclick="prevLesson()">‚¨Ö B√†i tr∆∞·ªõc</button>
            <button onclick="nextLesson()">‚û° B√†i sau</button>

            <button onclick="deleteCard()">üóë X√≥a th·∫ª</button>

            <div style="margin-top:12px; font-size:18px;">
                B√†i: <span id="lessonNum">1</span> ‚Äî
                Th·∫ª: <span id="cardNum">0</span>/<span id="cardTotal">0</span>
            </div>
        </div>

        <!-- FLASHCARD -->
        <div class="card">
            <div id="cardInner" class="inner" onclick="flipCard()">
                <div class="side front" id="frontCard">·∫§n ƒë·ªÉ l·∫≠t</div>
                <div class="side back" id="backCard">N·ªôi dung</div>
            </div>
        </div>

    </div>

    <div class="signature">Created by PHAM DANG KHOI</div>

<script>
/* ----------------- Core data ----------------- */
let lessons = [[]]; // array of lessons, each lesson is array of {front, back}
let currentLesson = 0;
let currentIndex = 0;

/* ------------- persistence (localStorage) -------------- */
const STORAGE_KEY = "denkhui_flashcards_v1";

function autoSave() {
    try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(lessons));
    } catch (e) {
        console.warn("AutoSave failed:", e);
    }
}

function loadFromLocal() {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (saved) {
        try {
            const parsed = JSON.parse(saved);
            if (Array.isArray(parsed)) lessons = parsed;
        } catch (e) { console.warn("Load parse error", e); }
    }
    // make sure structure valid
    if (!Array.isArray(lessons) || lessons.length === 0) lessons = [[]];
    if (!lessons[currentLesson]) { currentLesson = 0; }
    refreshDisplay();
}

/* ------------- UI refresh & card ops --------------- */
function refreshDisplay() {
    if (!lessons[currentLesson]) lessons[currentLesson] = [];
    let l = lessons[currentLesson];

    document.getElementById("lessonNum").textContent = currentLesson + 1;
    document.getElementById("cardTotal").textContent = l.length;
    document.getElementById("cardNum").textContent = l.length ? currentIndex + 1 : 0;

    if (l.length > 0) {
        const item = l[currentIndex] || l[0];
        document.getElementById("frontCard").textContent = item.front;
        document.getElementById("backCard").textContent = item.back;
    } else {
        document.getElementById("frontCard").textContent = "Kh√¥ng c√≥ th·∫ª";
        document.getElementById("backCard").textContent = "‚Äî";
    }
}

/* ------------- single-card functions --------------- */
function addCard() {
    const f = document.getElementById("frontInput").value.trim();
    const b = document.getElementById("backInput").value.trim();
    if (!f || !b) {
        alert("Nh·∫≠p m·∫∑t tr∆∞·ªõc v√† m·∫∑t sau tr∆∞·ªõc khi th√™m.");
        return;
    }
    lessons[currentLesson].push({ front: f, back: b });
    currentIndex = lessons[currentLesson].length - 1;
    document.getElementById("frontInput").value = "";
    document.getElementById("backInput").value = "";
    autoSave();
    refreshDisplay();
}

function deleteCard() {
    let l = lessons[currentLesson];
    if (!l || l.length === 0) return;
    if (!confirm("X√°c nh·∫≠n x√≥a th·∫ª hi·ªán t·∫°i?")) return;
    l.splice(currentIndex, 1);
    if (currentIndex >= l.length) currentIndex = l.length - 1;
    if (currentIndex < 0) currentIndex = 0;
    autoSave();
    refreshDisplay();
}

function flipCard() {
    document.getElementById("cardInner").classList.toggle("flipped");
}

function nextCard() {
    if (!lessons[currentLesson].length) return;
    currentIndex = (currentIndex + 1) % lessons[currentLesson].length;
    refreshDisplay();
}

function prevCard() {
    if (!lessons[currentLesson].length) return;
    currentIndex = (currentIndex - 1 + lessons[currentLesson].length) % lessons[currentLesson].length;
    refreshDisplay();
}

function nextLesson() {
    currentLesson++;
    if (!lessons[currentLesson]) lessons[currentLesson] = [];
    currentIndex = 0;
    autoSave();
    refreshDisplay();
}

function prevLesson() {
    if (currentLesson === 0) return;
    currentLesson--;
    currentIndex = 0;
    autoSave();
    refreshDisplay();
}

function saveToFile() {
    const data = JSON.stringify(lessons, null, 2);
    const blob = new Blob([data], { type: "application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "flashcard_DenKhui.json";
    a.click();
}

/* ------------- bulk import helpers -------------- */

/*
  parseLine:
  - supports separators: " - " (dash), "," , tab, or first whitespace group
  - returns {front, back} or null
*/
function parseLine(line) {
    line = line.trim();
    if (!line) return null;

    // try dash with spaces
    if (line.includes(" - ")) {
        const parts = line.split(" - ");
        return { front: parts[0].trim(), back: parts.slice(1).join(" - ").trim() };
    }
    // try simple dash (no spaces)
    if (line.includes("-")) {
        // but ensure not to split Japanese hyphen inside words too aggressively:
        const parts = line.split("-");
        if (parts.length >= 2) {
            return { front: parts[0].trim(), back: parts.slice(1).join("-").trim() };
        }
    }
    // try comma
    if (line.includes(",")) {
        const parts = line.split(",");
        return { front: parts[0].trim(), back: parts.slice(1).join(",").trim() };
    }
    // try tab
    if (line.includes("\t")) {
        const parts = line.split("\t");
        return { front: parts[0].trim(), back: parts.slice(1).join("\t").trim() };
    }
    // fallback: split by two or more spaces
    const m = line.split(/\s{2,}/);
    if (m.length >= 2) return { front: m[0].trim(), back: m.slice(1).join("  ").trim() };

    // final fallback: split by first space
    const idx = line.indexOf(" ");
    if (idx > -1) {
        return { front: line.slice(0, idx).trim(), back: line.slice(idx+1).trim() };
    }

    // can't parse single token
    return null;
}

/* Add from pasted textarea (Word) */
function bulkAddFromPaste() {
    const raw = document.getElementById("pasteFromWord").value.trim();
    if (!raw) { alert("D√°n n·ªôi dung Word v√†o √¥ tr∆∞·ªõc."); return; }

    const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(l => l.length>0);
    let added = 0;
    lines.forEach(line => {
        const parsed = parseLine(line);
        if (parsed && parsed.front && parsed.back) {
            lessons[currentLesson].push({ front: parsed.front, back: parsed.back });
            added++;
        }
    });

    autoSave();
    refreshDisplay();
    alert("ƒê√£ th√™m " + added + " th·∫ª v√†o B√†i " + (currentLesson+1));
    // clear paste area? keep as is to allow other pastes
}

/* Import from file: txt, csv, json */
function importBulkFile(evt) {
    const file = evt.target.files[0];
    if (!file) return;

    const name = file.name.toLowerCase();

    const reader = new FileReader();
    reader.onload = function(e) {
        const content = e.target.result;
        if (name.endsWith(".json") || file.type === "application/json") {
            // try parse JSON
            try {
                const parsed = JSON.parse(content);
                // if it looks like an array of lessons (your format), just replace/merge
                if (Array.isArray(parsed)) {
                    // Merge: append all lessons into current lesson OR replace? we'll append current lesson + offer both behaviours.
                    // Here: append parsed[0].. items into current lesson if parsed is [[{front,back}]]
                    if (Array.isArray(parsed[0]) && Array.isArray(parsed[0][0])) {
                        // nested deep, just flatten first-level arrays
                        parsed.forEach((lessonArray) => {
                            if (Array.isArray(lessonArray)) {
                                lessonArray.forEach(item => {
                                    if (item && item.front && item.back) lessons[currentLesson].push(item);
                                });
                            }
                        });
                    } else if (Array.isArray(parsed[0]) && parsed[0].length && parsed[0][0].front) {
                        // parsed like [[{front,back}]]
                        parsed[0].forEach(item => {
                            if (item && item.front && item.back) lessons[currentLesson].push(item);
                        });
                    } else if (parsed.length && parsed[0] && parsed[0].front) {
                        // parsed is array of cards
                        parsed.forEach(item => {
                            if (item && item.front && item.back) lessons[currentLesson].push(item);
                        });
                    } else {
                        // unknown JSON shape: try to find objects with front/back anywhere
                        alert("JSON kh√¥ng theo format chu·∫©n, th·ª≠ nh·∫≠p th·ªß c√¥ng ho·∫∑c m·ªü file v√† chuy·ªÉn sang TXT/CSV.");
                        return;
                    }
                    autoSave();
                    refreshDisplay();
                    alert("Import JSON th√†nh c√¥ng. C√°c th·∫ª ƒë√£ ƒë∆∞·ª£c g·ªôp v√†o b√†i hi·ªán t·∫°i.");
                    return;
                } else {
                    alert("JSON kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng array. (C·∫ßn array c√°c th·∫ª ho·∫∑c array c√°c b√†i).");
                    return;
                }
            } catch (err) {
                alert("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c JSON: " + err);
                return;
            }
        } else {
            // treat as text/csv
            const rows = content.split(/\r?\n/).map(r => r.trim()).filter(r => r.length>0);
            let added = 0;
            rows.forEach(row => {
                const p = parseLine(row);
                if (p && p.front && p.back) {
                    lessons[currentLesson].push(p);
                    added++;
                }
            });
            autoSave();
            refreshDisplay();
            alert("Import file th√†nh c√¥ng: ƒë√£ th√™m " + added + " th·∫ª.");
        }
    };

    // read as text (for txt/csv/json)
    reader.readAsText(file);
}

/* Clear current lesson (destructive) */
function clearCurrentLesson() {
    if (!confirm("X√≥a to√†n b·ªô th·∫ª trong b√†i hi·ªán t·∫°i? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.")) return;
    lessons[currentLesson] = [];
    currentIndex = 0;
    autoSave();
    refreshDisplay();
}

/* show format example modal (simple) */
function showExample() {
    const example = "V√≠ d·ª• c√°c d√≤ng h·ª£p l·ªá (m·ªói d√≤ng 1 th·∫ª):\n\n" +
                    "Áä¨ - con ch√≥\n" +
                    "Áå´, con m√®o\n" +
                    "Ê∞¥\tn∆∞·ªõc (tab ph√¢n c√°ch)\n" +
                    "Á©∫ b·∫ßu tr·ªùi (c√°ch 2 kho·∫£ng tr·∫Øng ho·∫∑c 1 kho·∫£ng)\n\n" +
                    "B·∫°n c√≥ th·ªÉ copy t·ª´ Word v√† paste th·∫≥ng v√†o √¥ 'Paste t·ª´ Word'.";
    alert(example);
}

/* ------------- initialize on load -------------- */
loadFromLocal();

/* make flip clickable only when card exists: handled via onclick */
/* optional: keyboard shortcuts */
document.addEventListener('keydown', function(e) {
    // left/right arrows for cards, up/down for lessons
    if (e.key === 'ArrowRight') nextCard();
    if (e.key === 'ArrowLeft') prevCard();
    if (e.key === 'ArrowUp') prevLesson();
    if (e.key === 'ArrowDown') nextLesson();
});
</script>

<style>
/* C√°nh hoa anh ƒë√†o th·∫≠t 100%, kh√¥ng ch·ªØ, kh√¥ng troll */
.petal {
    position: fixed;
    top: -50px;
    pointer-events: none;
    width: 24px;
    height: 24px;
    background: radial-gradient(circle at 30% 30%, #ffb7e5, #ff9edf);
    border-radius: 50% 50% 50% 0;
    transform: rotate(-30deg);
    box-shadow: 0 0 12px #fff;
    animation: sakuraFall linear infinite;
    z-index: 999;
}
@keyframes sakuraFall {
    0%   { transform: translateY(-100vh) rotate(0deg) translateX(0); opacity: 0; }
    10%  { opacity: 1; }
    100% { transform: translateY(110vh) rotate(720deg) translateX(100px); opacity: 0; }
}
</style>

<script>
// T·∫°o c√°nh hoa th·∫≠t, kh√¥ng ch·ªØ, bay nghi√™ng nghi√™ng nh∆∞ th·∫≠t lu√¥n
function createSakura() {
    const p = document.createElement("div");
    p.classList.add("petal");
    p.style.left = Math.random() * 100 + "vw";
    p.style.width = p.style.height = (Math.random() * 12 + 18) + "px";
    p.style.animationDuration = (Math.random() * 12 + 12) + "s";
    p.style.animationDelay = Math.random() * 8 + "s";
    p.style.opacity = Math.random() * 0.5 + 0.6;
    document.body.appendChild(p);
    setTimeout(() => p.remove(), 30000);
}

// R∆°i li√™n t·ª•c, nh·∫π nh√†ng
setInterval(createSakura, 250);
for(let i = 0; i < 40; i++) {
    setTimeout(createSakura, i * 300);
}
</script>
</body>
</html>
